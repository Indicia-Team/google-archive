<?php// $Id$/** * Menu callback for the import form */function import_species_accounts_form() {  $form = array();  // hide some known node types that we definitely don't want to import.  $types = array_diff_key(      node_get_types('names'),      array(        'page'=>'',        'story'=>'',        'iform'=>'',        'forum'=>''      )  );  $form['sai_node_type'] = array(    '#type' => 'select',    '#title' => t('Type of content to import'),    '#description' => t('Select the node type you want to import data into'),    '#required' => true,    '#options' => $types,    '#default_value' => variable_get('sai_last_imported_type', '')  );  $form['sai_species_data'] = array(    '#type' => 'textarea',    '#title' => t('Species Account Raw Data'),    '#size' => 100,    '#description' => t('Paste data into here copied from an Atlas PDF file'),    '#required' => true,    '#wysiwyg' => false  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Import')      );   return $form;}function import_species_accounts_form_submit($form, &$form_state) {  require_once ('species_account_importer.defines.inc');  $text = trim($form_state['values']['sai_species_data']);  variable_set('sai_last_imported_type', $form_state['values']['sai_node_type']);  $lines = preg_split("/(\r?\n)/", $text);  // remove any control characters from the start. Allow a * as this can mark the start of a species  $lines[0] = preg_replace('/^[^\w\*]*/', '', $lines[0]);    $fields = content_fields(null, $form_state['values']['sai_node_type']);  // extract the labels we are searching for in the text  $fieldlabels = array();  foreach ($fields as $field=>$def) {    $fieldlabels[$field]=$def['widget']['label'];  }  $species_regexp = variable_get('sai_species_regex', SAI_DEFAULT_SPECIES_REGEX);  $currentAccount = null;  $currentField = '';  $currentText = '';  // Use a regexp to spliy lines so we can tolerate any line endings  $ignores = preg_split('/[\r\n]+/', variable_get('sai_species_ignore_regex', SAI_DEFAULT_IGNORE_REGEX));  $ranks = preg_split('/[\r\n]+/', variable_get('sai_ranks', SAI_DEFAULT_RANKS));  // make ranks into an assoc array with blank values ready to fill in for each species  $vals = array_fill(0, count($ranks), '');  $ranks = array_combine($ranks, $vals);  $rank_regexes = preg_split('/[\r\n]+/', variable_get('sai_rank_regexes', SAI_DEFAULT_RANK_REGEXES));  foreach ($lines as $line) {    $lineNoSpace = str_replace(' ','',$line);    $skip = false;    foreach ($ignores as $ignore) {      if (preg_match($ignore, $lineNoSpace)) {        $skip = true;        drupal_set_message("ignored $line");        break; // only from the ignore checking loop      }    }    if (isset($currentRanks))       // look through the rank regexps to see if we can pick out some rank info from the text      foreach ($rank_regexes as $regex) {        if (preg_match($regex, $lineNoSpace, $matches)) {          // remove the indexes from the matches array, leaving just the named match patterns          $matches = array_intersect_key($matches, $ranks);          // update the current ranks array with the found values          $currentRanks = array_merge($currentRanks, $matches);        }      }    if (!$skip) {      if (preg_match($species_regexp, $line, $matches)) {        sai_saveAccount($currentAccount, $currentField, $currentText, $currentRanks);        // see if the node already exists by matching the species name        $currentAccount = node_load(array(          'title' => $matches['name'],          'type' => $form_state['values']['sai_node_type']        ));        // if it does not exist, create a new node object        if (!($currentAccount && $currentAccount->nid)) {          $currentAccount = new StdClass();          $currentAccount->type=$form_state['values']['sai_node_type'];          $currentAccount->title=$matches['name'];        }        $currentField = null;        if (variable_get('sai_content_type_rank', SAI_DEFAULT_CONTENT_TYPE_RANK)) {          // Configuration indicates that we need to insert a rank at the top level to reflect the species account page type.           $typeRank = $form_state['values']['sai_node_type'];          // If the node type is, e.g. Wasp Account, we just want to insert Wasp at the top level.          if (preg_match('/\_accounts?$/', $typeRank))            $typeRank = trim(ucfirst(substr($typeRank, 0, strlen(str_replace('_', ' ', $typeRank))-8)));          $currentRanks = array_merge(array('top' => $typeRank), $ranks);        } else          $currentRanks = array_merge($ranks);        drupal_set_message('Found a line '.$line);      } elseif ($currentAccount) {        $normalLine=true;        // ignore colon at         $testHeading = strtolower(str_replace(':', '', $lineNoSpace));        foreach ($fieldlabels as $field=>$label) {          if ($testHeading===strtolower(str_replace(' ', '', $label))) {            sai_saveField($currentAccount, $currentField, $currentText);            $currentField = $field;            // this line is a field header, not a normal line            $normalLine=false;          }        }        if ($normalLine)          $currentText .= $line . "\r\n";      }    }  }  drupal_set_message('final save');  sai_saveAccount($currentAccount, $currentField, $currentText, $currentRanks);}/** * Saves a species account node, if there is one to save. Also ensures the most recent bit of  * field data is stored in the node. * @param type $account * @param type $field * @param type $text  * @param array $ranks List of taxonomic ranks for this species. *  * @todo: Handle ranks information */function sai_saveAccount(&$account, &$field, &$text, &$ranks) {  if ($account) {    drupal_set_message("saving account");     sai_saveField($account, $field, $text);    // should we extract the author string from the species name and put it in a separate field?    if (variable_get('sai_extract_authority_field', SAI_DEFAULT_EXTRACT_AUTHORITY_FIELD)) {      $epithets = explode(' ', $account->title);      // need to extract the authority into a particular field      $field = 'field_'.variable_get('sai_extract_authority_field', SAI_DEFAULT_EXTRACT_AUTHORITY_FIELD);      // reconstruct the author (which is anything after the binomial species name).      $author = implode(' ', array_slice($epithets, 2));      $account->$field=array(array('value' => trim($author)));      // update the node title to exclude the author      $account->title = trim(implode(' ', array_slice($epithets, 0, 2)));    }    // if the path module is enabled, let's build a nice path.    if (module_exists('path')) {      // this cleans up the path to only alphanumerics. Single quotes are removed, other chars are replaced by -.      $path = array_values($ranks);      // remove any empty items from the path array      $path = array_filter($path, 'strlen');      // add the species      $path[] = $account->title;      $account->path = strtolower(preg_replace(array('/\'/', '/[^a-zA-Z0-9\/]/'), array('', '-'), implode('/', $path)));          }    node_save($account);    // Here, need to create a taxonomy hierarchy from the ranks information    sai_createRanks($account, $ranks);    $account = null;  } else     drupal_set_message("blank account: ".print_r($account, true));}function sai_createRanks(&$node, &$ranks) {  $vid =  sai_get_vid();  // If we are treating names as binomials, we can extract the genus  if (variable_get('sai_extract_genus', SAI_DEFAULT_EXTRACT_GENUS) || variable_get('sai_extract_authority', SAI_DEFAULT_EXTRACT_AUTHORITY)) {    $epithets = explode(' ', $node->title);    $ranks['Genus'] = $epithets[0];  }  // We also want a term for the node's species  $ranks['Species'] = $node->title;  if ($vid) {    $parent = 0;    foreach($ranks as $rank=>$taxon) {      // we can skip levels if the taxon is not provided      if ($taxon) {        if ($term = db_fetch_object(db_query("SELECT tid FROM {term_data} WHERE vid=%d AND name='%s'", $vid, $taxon)))          $tid = $term->tid;        else {          db_query("INSERT INTO {term_data} (vid, name, description, weight) VALUES (%d, '%s', '%s', %d)", $vid, $taxon, $rank, 0);          $tid = db_last_insert_id('{term_data}', 'tid');        }        if (db_fetch_object(db_query("SELECT tid FROM {term_hierarchy} WHERE tid=%d", $tid))===false)          db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)", $tid, $parent);        else          db_query("UPDATE {term_hierarchy} SET parent=%d WHERE tid=%d", $parent, $tid);        $parent = $tid;      }    }    // Hook the node to the species rank term.    if ($exist=db_fetch_object(db_query("SELECT tn.tid, tn.vid FROM {term_node} tn ".        "INNER JOIN {term_data} t ON t.tid=tn.tid ".        "WHERE t.vid=%d AND tn.nid=%d", $vid, $node->nid))===false)      db_query("INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)", $node->nid, $node->vid, $tid);    else      db_query("UPDATE {term_node} SET tid=%d WHERE vid=%d AND tid=%d", $tid, $exist->vid, $exist->tid);    $ranks = null;  }}function sai_saveField(&$account, &$field, &$text) {  if ($field) {    $account->$field=array(array('value' => trim($text)));  } else {    $account->body = trim($text);  }  $field = '';  $text = '';}