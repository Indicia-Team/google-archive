<?php// $Id$/** * Menu callback for the import form for species account texts */function import_species_accounts_form() {  $form = array();  // hide some known node types that we definitely don't want to import.  $types = array_diff_key(      node_get_types('names'),      array(        'page'=>'',        'story'=>'',        'iform'=>'',        'forum'=>''      )  );  $form['sai_node_type'] = array(    '#type' => 'select',    '#title' => t('Type of content to import'),    '#description' => t('Select the node type you want to import data into'),    '#required' => true,    '#options' => $types,    '#default_value' => variable_get('sai_last_imported_type', '')  );  $form['sai_species_data'] = array(    '#type' => 'textarea',    '#title' => t('Species Account Raw Data'),    '#size' => 100,    '#description' => t('Paste data into here copied from an Atlas PDF file'),    '#required' => true,    '#wysiwyg' => false  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Import')  );  return $form;}/** * Menu callback for the import form for species account images */function import_species_images_form() {  $form=array();  // allow file upload  $form['#attributes']['enctype'] = "multipart/form-data";  $form['instruction'] = array(    '#value' => '<p>' . t('To import species images, you must upload jpg image files to the '.          'sites/default/files/species_images folder or the site specific version of this folder if using a Drupal multisite install. Then provide a CSV '.          'file with 3 columns called file, caption and credits.  The first must contain the name of each file that has been placed in the species_images '.          'folder. There should be a content type with machine name set to image, that has text fields called field_caption and field_credits, an integer '.          'field called field_weight and an image file field called field_image.') . '</p>'  );  $form['images_csv_file'] = array(    '#type' => 'file',    '#title' => t('CSV File'),    '#description' => t('Select the CSV file to upload.')  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Import')  );  return $form;}function import_species_images_form_validate() {  // #required does not work on Drupal file upload types, so we check here  if(!count($_FILES)) {    form_set_error('images_csv_file', 'Please select a file to upload.');  }}/** * Submit handler for the import species account texts form. */function import_species_accounts_form_submit($form, &$form_state) {  require_once ('species_account_importer.defines.inc');  $text = trim($form_state['values']['sai_species_data']);  variable_set('sai_last_imported_type', $form_state['values']['sai_node_type']);  $lines = preg_split("/(\r?\n)/", $text);  // remove any control characters from the start. Allow a * as this can mark the start of a species  $lines[0] = preg_replace('/^[^\w\*]*/', '', $lines[0]);  $fields = content_fields(null, $form_state['values']['sai_node_type']);  // extract the labels we are searching for in the text  $fieldlabels = array();  foreach ($fields as $field=>$def) {    $fieldlabels[$field]=$def['widget']['label'];  }  $species_regexp = variable_get('sai_species_regex', SAI_DEFAULT_SPECIES_REGEX);  $currentAccount = null;  $currentField = '';  $currentText = '';  // Use a regexp to spliy lines so we can tolerate any line endings  $ignores = preg_split('/[\r\n]+/', variable_get('sai_species_ignore_regex', SAI_DEFAULT_IGNORE_REGEX));  $ranks = preg_split('/[\r\n]+/', variable_get('sai_ranks', SAI_DEFAULT_RANKS));  // make ranks into an assoc array with blank values ready to fill in for each species  $vals = array_fill(0, count($ranks), '');  $ranks = array_combine($ranks, $vals);  $rank_regexes = preg_split('/[\r\n]+/', variable_get('sai_rank_regexes', SAI_DEFAULT_RANK_REGEXES));  $haveRankInfo = false;  foreach ($lines as $line) {    $line = trim($line);    $lineNoSpace = str_replace(' ','',$line);    $skip = false;    foreach ($ignores as $ignore) {      if (preg_match($ignore, $lineNoSpace)) {        $skip = true;        break; // only from the ignore checking loop      }    }    if (isset($currentRanks))      // look through the rank regexps to see if we can pick out some rank info from the text      foreach ($rank_regexes as $regex) {        if (preg_match($regex, $lineNoSpace, $matches)) {          // remove the indexes from the matches array, leaving just the named match patterns          $matches = array_intersect_key($matches, $ranks);          // update the current ranks array with the found values          $currentRanks = array_merge($currentRanks, $matches);          $haveRankInfo = true;        }      }    if (!$skip) {      if (preg_match($species_regexp, $line, $matches)) {        // save the account from the last iteration. We update ranks always for a new node, but only if we found some rank info        // for an existing node.         sai_saveAccount($currentAccount, $currentField, $currentText, $currentRanks, $haveRankInfo || ($currentAccount->id===0));        $haveRankInfo = false;        // get the new account title, with any double spaces converted to single as these can mess up things.        $title = preg_replace("'\s+'", ' ', $matches['name']);        // should we extract the author string from the species name and put it in a separate field?        if (variable_get('sai_extract_authority_field', SAI_DEFAULT_EXTRACT_AUTHORITY_FIELD)) {          $epithets = explode(' ', $title);          // reconstruct the author (which is anything after the binomial species name).          if (count($epithets)>2 && $epithets[2]=='s.l.' || $epithets[2]=='s.s.')            // abbreviated sensu stricto or sensu lato, so there is Genus + Species + abbreviation (=3 parts to the name).            $partCount=3;          elseif (count($epithets)>2 && $epithets[2]=='sensu')            // full sensu stricta or sensu lato, so there is Genus + Species + sensu + stricto|lato (=4 parts to the name).            $partCount=4;          else             // default is genus plus species            $partCount=2;          $author = implode(' ', array_slice($epithets, $partCount));          // update the node title to exclude the author          $title = trim(implode(' ', array_slice($epithets, 0, $partCount)));        }        // see if the node already exists by matching the species name        $currentAccount = node_load(array(          'title' => $title,          'type' => $form_state['values']['sai_node_type']        ));        // if it does not exist, create a new node object        if (!($currentAccount && $currentAccount->nid)) {          $currentAccount = new StdClass();          $currentAccount->type=$form_state['values']['sai_node_type'];          $currentAccount->title=$title;        }        if (variable_get('sai_extract_authority_field', SAI_DEFAULT_EXTRACT_AUTHORITY_FIELD)) {          // need to extract the authority into a particular field          $field = 'field_'.variable_get('sai_extract_authority_field', SAI_DEFAULT_EXTRACT_AUTHORITY_FIELD);          $currentAccount->$field=array(array('value' => trim($author)));        }        $currentField = null;        if (variable_get('sai_content_type_rank', SAI_DEFAULT_CONTENT_TYPE_RANK)) {          // Configuration indicates that we need to insert a rank at the top level to reflect the species account page type.          $typeRank = $form_state['values']['sai_node_type'];          // If the node type is, e.g. Wasp Account, we just want to insert Wasp at the top level.          if (preg_match('/\_accounts?$/', $typeRank))            $typeRank = trim(ucfirst(substr($typeRank, 0, strlen(str_replace('_', ' ', $typeRank))-8)));          $currentRanks = array_merge(array('top' => $typeRank), $ranks);        } else          $currentRanks = array_merge($ranks);        drupal_set_message('Found an account starting with '.$line);      } elseif ($currentAccount) {        $normalLine=true;        // ignore colon at        $testHeading = strtolower(str_replace(':', '', $lineNoSpace));        foreach ($fieldlabels as $field=>$label) {          if ($testHeading===strtolower(str_replace(' ', '', $label))) {            sai_saveField($currentAccount, $currentField, $currentText);            $currentField = $field;            // this line is a field header, not a normal line            $normalLine=false;          }        }        if ($normalLine)          $currentText .= $line . "\r\n";      }    }  }  sai_saveAccount($currentAccount, $currentField, $currentText, $currentRanks, $haveRankInfo);}/** * Submit handler for the import species account texts form. */function import_species_images_form_submit($form, &$form_state) {  $file = file_save_upload('images_csv_file');  // path to the image files on the disk  $filesDir = $_SERVER['DOCUMENT_ROOT'] . base_path().file_directory_path().'/species_images/';  if (($handle = fopen($file->filepath, "r")) !== FALSE) {    $r = '';    if ((($header = fgetcsv($handle, 1000, ",")) !== FALSE)) {      // work out the positions of the 3 columns we need      foreach ($header as $idx=>$value) {        if (strcasecmp(trim($value), 'file')===0)          $fileIdx = $idx;        elseif (strcasecmp(trim($value), 'caption')===0)          $captionIdx = $idx;        elseif (strcasecmp(trim($value), 'credits')===0)          $creditIdx = $idx;      }      if (!isset($fileIdx) || !isset($captionIdx) || !isset($creditIdx)) {        drupal_set_message('The uploaded file must be a CSV file with columns called file, caption and credits.', 'error');        return;      }      $count=0;      $created=0;      $updated=0;      while (($data = fgetcsv($handle, 1000, ",")) !== FALSE) {        // skip blank rows        if ($data[$fileIdx]==='')          continue;        $count++;        $filename = trim($data[$fileIdx]);        watchdog('import', 'Row ' . $filename . ' ' . $data[$captionIdx] . ' ' . $data[$creditIdx]);        if (preg_match('/^(?P<genus>[a-zA-Z]+)\-(?P<species>[a-zA-Z]+)\_(?P<weight>[\d+])/', $filename, $matches)) {          $species = $matches['genus'].' '.$matches['species'];          // find the taxonomy term which matches the species          $result = db_query('select tid from {term_data} where name=\'%s\' and vid=%d', $species, variable_get('sai_vid', 0));          // default file extension is .jpg, but we need to take care of case sensitivity!          if (strtolower(substr($filename, -4))!=='.jpg') {            if (file_exists($filesDir.$filename.'.jpg'))              $filename .= '.jpg';            elseif (file_exists($filesDir.$filename.'.JPG'))              $filename .= '.JPG';          }          if (file_exists($filesDir.$filename)) {            if ($term = db_fetch_object($result)) {              // now we need to create an image node, and then attach it to the term. Of course that is unless the image already exists?              $result = db_query('select n.nid from {node} n '.                  'inner join {content_type_image} i on i.nid=n.nid '.                  'inner join {files} f on f.fid=i.field_image_fid '.                  'where n.type = \'image\' '.                  'and f.filename=\'%s\'', $filename);              if ($node = db_fetch_object($result)) {                $node = node_load($node->nid);                $updated++;              }              else {                $node = new stdClass();                $created++;              }              $filepath = file_directory_path().'/species_images/'.$filename;              $result = db_query('select * from {files} where filepath=\'%s\'', $filepath);              if (!$file=db_fetch_array($result)) {                // Create the record in files                $file              = array();                $file['filename']  = $filename;                $file['filepath']  = $filepath;                $file['filemime']  = 'image/jpg';                $file['filesize']  = filesize($filesDir.$filename);                $file['uid']       = $user->uid;                $file['timestamp'] = time();                $file['status']  = FILE_STATUS_PERMANENT;                drupal_write_record('files', $file);                watchdog('import', 'Created file '.$filename);              } else {                watchdog('import', 'Using existing file for '.$filename);              }              $file['list'] = 1;              $file['title']  = $filename;              $node->title = 'Image '.$filename;              $node->type='image';              $node->uid = $user->uid;              $node->field_image=array($file);              $node->field_caption=array(array('value'=>$data[$captionIdx]));              $node->field_credits=array(array('value'=>$data[$creditIdx]));              $node->field_weight=array(array('value'=>$matches['weight']));;              node_save($node);              $result = db_query('select nid from {term_node} where nid=%d', $node->nid);              if ($termNode = db_fetch_object($result))                // term data record already exists for this node, so just ensure it is linked to the correct term                db_query('update {term_node} set tid=%d where nid=%d', $term->tid, $node->nid);              else                db_query('insert into {term_node} (nid, vid, tid) values (%d, %d, %d)', $node->nid, $node->vid, $term->tid);            } else {              watchdog('import', "No term for $species could be found in the Drupal vocabulary.", null, WATCHDOG_WARNING);            }          } else {            watchdog('import', 'File '.$filesDir.$filename.' referred to in CSV file but not found.', null, WATCHDOG_WARNING);          }        } else {          watchdog('import', 'The image file '.$filename.' is not of a recognisable format to identify the species name from.', null, WATCHDOG_WARNING);        }      }      fclose($handle);      drupal_set_message("Upload complete. $count rows were scanned, resulting in $created new images and $updated changed images.");      return;    }  } else {    drupal_set_message('The uploaded file could not be opened', 'error');    return;  }}/** * Saves a species account node, if there is one to save. Also ensures the most recent bit of * field data is stored in the node. * @param type $account * @param type $field * @param type $text * @param array $ranks List of taxonomic ranks for this species. * @param boolean $updateRanks Can be set to false if the rank (= taxonomy) of the current node should not be updated. * * @todo: Handle ranks information */function sai_saveAccount(&$account, &$field, &$text, &$ranks, $updateRanks) {  if ($account) {    sai_saveField($account, $field, $text);    node_save($account);    // Here, need to create a taxonomy hierarchy from the ranks information    if ($updateRanks) {      // if the path module is enabled, let's build a nice path.      if (module_exists('path')) {        // this cleans up the path to only alphanumerics. Single quotes are removed, other chars are replaced by -.        $path = array_values($ranks);        // remove any empty items from the path array        $path = array_filter($path, 'strlen');        // add the species        $path[] = $account->title;        // delete any existing paths        if ($account->nid)          db_query("DELETE FROM {url_alias} WHERE src = 'node/%d'", $account->nid);        $alias = strtolower(preg_replace(array('/\'/', '/[^a-zA-Z0-9\/]/'), array('', '-'), implode('/', $path)));        path_set_alias('node/'.$account->nid, $alias);        drupal_set_message('Path set to '.$alias);      }      sai_createRanks($account, $ranks);    }    $account = null;  }}function sai_createRanks(&$node, &$ranks) {  drupal_set_message(print_r($ranks, true));  $vid =  sai_get_vid();  // If we are treating names as binomials, we can extract the genus  if (variable_get('sai_extract_genus', SAI_DEFAULT_EXTRACT_GENUS) || variable_get('sai_extract_authority', SAI_DEFAULT_EXTRACT_AUTHORITY)) {    $epithets = explode(' ', $node->title);    $ranks['Genus'] = $epithets[0];  }  // We also want a term for the node's species  $ranks['Species'] = $node->title;  if ($vid) {    $parent = 0;    foreach($ranks as $rank=>$taxon) {      // we can skip levels if the taxon is not provided      if ($taxon) {        if ($term = db_fetch_object(db_query("SELECT tid FROM {term_data} WHERE vid=%d AND name='%s'", $vid, $taxon)))          $tid = $term->tid;        else {          db_query("INSERT INTO {term_data} (vid, name, description, weight) VALUES (%d, '%s', '%s', %d)", $vid, $taxon, $rank, 0);          $tid = db_last_insert_id('{term_data}', 'tid');        }        if (db_fetch_object(db_query("SELECT tid FROM {term_hierarchy} WHERE tid=%d", $tid))===false)          db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)", $tid, $parent);        else          db_query("UPDATE {term_hierarchy} SET parent=%d WHERE tid=%d", $parent, $tid);        $parent = $tid;      }    }    // Hook the node to the species rank term.    if ($exist=db_fetch_object(db_query("SELECT tn.tid, tn.vid FROM {term_node} tn ".        "INNER JOIN {term_data} t ON t.tid=tn.tid ".        "WHERE t.vid=%d AND tn.nid=%d", $vid, $node->nid))===false)      db_query("INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)", $node->nid, $node->vid, $tid);    else      db_query("UPDATE {term_node} SET tid=%d WHERE vid=%d AND tid=%d", $tid, $exist->vid, $exist->tid);    $ranks = null;  }}function sai_saveField(&$account, &$field, &$text) {  $text = trim($text);  if ($field) {    $account->$field=array(array('value' => $text));  } else {    // Don't commit empty text into the body, as this most likely means we are updating some fields in an existing account but not the body.    if (!empty($text))      $account->body = $text;  }  $field = '';  $text = '';}