<?php// $Id$/** * Preset storage constant for user-defined presets in the DB. */define('TAXON_FORMATTERS_STORAGE_NORMAL', 0);/** * Preset storage constant for module-defined presets in code. */define('TAXON_FORMATTERS_STORAGE_DEFAULT', 1);/** * Preset storage constant for user-defined presets that override module-defined presets. */define('TAXON_FORMATTERS_STORAGE_OVERRIDE', 2);/** * Implementation of hook_menu(). * @todo setup access arguments */function taxon_formatters_menu() {  $items = array();  $items['admin/build/taxon_formatters'] = array(    'title' => 'Taxon Formatters',    'file' => 'taxon_formatters.pages.inc',    'description' => 'Administer taxon formatter presets and actions.',    'page callback' => 'taxon_formatters_preset_overview',    'access arguments' => array('administer taxon_formatters'),  );  $items['admin/build/taxon_formatters/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/build/taxon_formatters/add'] = array(    'title' => 'Add new preset',    'file' => 'taxon_formatters.pages.inc',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxon_formatters_preset_form'),    'access arguments' => array('administer taxon_formatters'),    'type' => MENU_LOCAL_TASK,  );   $items['admin/build/taxon_formatters/%taxon_formatters_preset'] = array(    'title callback' => 'taxon_formatter_preset_title_callback',    'title arguments' => array('Edit preset: !presetname', 3),    'file' => 'taxon_formatters.pages.inc',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxon_formatters_preset_form', 3),    'access arguments' => array('administer taxon_formatters'),    'type' => MENU_CALLBACK,  );  $items['admin/build/taxon_formatters/%taxon_formatters_preset/delete'] = array(    'title callback' => 'taxon_formatter_preset_title_callback',    'title arguments' => array('Delete preset: !presetname', 3),    'file' => 'taxon_formatters.pages.inc',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxon_formatters_preset_delete_form', 3),    'access arguments' => array('administer taxon_formatters'),    'type' => MENU_CALLBACK,  );  // Register an ajax path which retrieves the page settings appropriate to the selected formatter.   // This allows the add/edit form to dynamically generate when selecting the formatter in the drop down menu.  $items['taxon_formatter_settings/js/%'] = array(    'page callback' => 'get_settings_js',    'page arguments' => array(2),    'access arguments' => array('access content'),    'type ' => MENU_CALLBACK,  );  return $items;}/** * Get an array of all presets and their settings. * * @param reset *   if set to TRUE it will clear the preset cache * * @return *   array of presets array( $preset_id => array('presetid' => integer, 'presetname' => string, 'type' => string)) */function taxon_formatters_presets($reset = FALSE) {  static $presets = array();  // Clear  caches if $reset is TRUE;  if ($reset) {    $presets = array();    cache_clear_all('taxon_formatters:presets', 'cache');    // Clear the content.module cache (refreshes the list of formatters provided by taxon_formatters.module).    if (module_exists('content')) {      content_clear_type_cache();    }  }  // Return presets if the array is populated.  if (!empty($presets)) {    return $presets;  }  // Grab from cache or build the array.   if (($cache = cache_get('taxon_formatters:presets', 'cache'))) {    $presets = $cache->data;  }  else {    $normal_presets = array();    $result = db_query('SELECT * FROM {taxon_formatters_preset} ORDER BY presetname');    while ($preset = db_fetch_array($result)) {      $presets[$preset['presetid']] = $preset;      $preset['storage'] = TAXON_FORMATTERS_STORAGE_NORMAL;      // Collect normal preset names so we can skip defaults and mark overrides accordingly      $normal_presets[$preset['presetname']] = $preset['presetid'];    }    // Collect default presets and allow modules to modify them before they    // are cached.    $default_presets = module_invoke_all('taxon_identifiers_default_presets');    drupal_alter('taxon_identifiers_default_presets', $default_presets);    // Add in default presets if they don't conflict with any normal presets.    // Mark normal presets that take the same preset namespace as overrides.    foreach ($default_presets as $preset) {      if (!empty($preset['presetname'])) {        if (!isset($normal_presets[$preset['presetname']])) {          $preset['storage'] = TAXON_FORMATTERS_STORAGE_DEFAULT;          // Use a string preset identifier          $preset['presetid'] = $preset['presetname'];          $presets[$preset['presetname']] = $preset;        }        else {          $presetid = $normal_presets[$preset['presetname']];          $presets[$presetid]['storage'] = TAXON_FORMATTERS_STORAGE_OVERRIDE;        }      }    }    cache_set('taxon_formatters:presets', $presets);  }  return $presets;}/** * Gets a list of taxon formatter types. */function taxon_formatter_types($reset = FALSE) {  static $types=array();  if ($reset) {    $types = array();    cache_clear_all('taxon_formatters:types', 'cache');  }  // Return presets if the array is populated.  if (!empty($presets)) {    return $presets;  }      // Grab from cache or build the array.   if (($cache = cache_get('taxon_formatters:types', 'cache'))) {    $types = $cache->data;  }  else {    $types = module_invoke_all('taxon_formatter_types');  }  return $types;}/*** Returns a list of the taxon formatters that are available as exposed by other modules.*/function taxon_formatters_formatters() {  return module_invoke_all('taxon_formatter');}/** * The AHAH callback function which receieves AJAX requests for updates to the  * settings for the selected formatter * @return unknown_type */function get_settings_js() {    // The form is generated in an include file which we need to include manually.  include_once 'modules/node/node.pages.inc';  include_once drupal_get_path('module', 'taxon_formatters').'/taxon_formatters.pages.inc';  $form_state = array('storage' => NULL, 'submitted' => FALSE);  $form_build_id = $_POST['form_build_id'];  // Get the form from the cache.  $form = form_get_cache($form_build_id, $form_state);    $args = $form['#parameters'];  $form_id = array_shift($args);  // We need to process the form, prepare for that by setting a few internals.  $form_state['post'] = $form['#post'] = $_POST;    unset($form['#post']['form_id']);    $form['#programmed'] = $form['#redirect'] = FALSE;  // Build, validate and if possible, submit the form.  drupal_process_form($form_id, $form, $form_state);      // This call recreates the form relying solely on the form_state that the  // drupal_process_form set up.  $form = drupal_rebuild_form($form_id, $form_state, $args, $form_build_id);    $settings_form = $form['taxon_formatter_params']['taxon_formatter_params_wrapper'];  unset($params_form['#prefix'], $params_form['#suffix']);  $output = theme('status_messages') . drupal_render($settings_form);    // Final rendering callback.  drupal_json(array('status' => TRUE, 'data' => $output));}/** * Menu wildcard loader. */function taxon_formatters_preset_load($preset_id) {  return taxon_formatters_preset($preset_id, TRUE);}/** * Load a preset by preset_id. * * @param preset_id *   The numeric id of a preset. * * @return *   preset array( 'presetname' => string, 'presetid' => integet) *   empty array if preset_id is an invalid preset */function taxon_formatters_preset($preset_id, $reset = FALSE) {  $presets = taxon_formatters_presets($reset);  return (isset($presets[$preset_id])) ? $presets[$preset_id] : array();}function taxon_formatter_preset_title_callback($title, $preset = array(), $action = array()) {  $replacements = array();  if (!empty($preset)) {    $replacements['!presetname'] = $preset['presetname'];    $replacements['!presetid'] = $preset['presetid'];  }  if (!empty($action) && !is_array($action)) {    $replacements['!actionname'] = $action;  }  elseif (!empty($action)) {    $replacements['!action'] = $action['action'];  }  return t($title, $replacements);}function taxon_formatters_preset_delete($preset) {  db_query('DELETE FROM {taxon_formatters_preset} where presetid = %d', $preset['presetid']);  taxon_formatters_presets(TRUE);  return TRUE;}/** Implementation of hook_field_formatter_info().*/function taxon_formatters_field_formatter_info() {  $formatTypes = taxon_formatter_types();  $formatters=array();  foreach (taxon_formatters_presets() as $presetid=>$preset) {    $formatters['tf_'.$presetid] = array(        'label' => t($preset['presetname']),        'field types' => array($formatTypes[$preset['type']]['field_type'])    );  }  return $formatters;}/** * Implement hook_theme. * Generates theme functions for each formatter preset. */function taxon_formatters_theme() {  $theme = array();  foreach (taxon_formatters_presets() as $presetid=>$preset) {    $theme["taxon_formatters_formatter_tf_$presetid"] = array(      'arguments' => array('element' => NULL),      'function' => 'theme_taxon_formatters_formatter',    );  }  return $theme;}function theme_taxon_formatters_formatter($element) {  // Extract the preset id from the formatter name.    $presetid = substr($element['#formatter'], 3);  $presets = taxon_formatters_presets();  $preset = $presets[$presetid];  // convert the settings json into a readable array  $preset['settings'] = json_decode($preset['settings'], true);  return theme($preset['type'].'_taxon_formatter_output', $element, $preset);}