<?php

/**
 * Implementation of hook menu.
 * Exposes a form that can resolve the case when there are several possible users that this account can be linked to
 * on the warehouse.
 */
function easy_login_menu() {
  $items['resolve_multiple_users'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments'   => array('resolve_multiple_users_form'),
    'type' => MENU_CALLBACK,
    'access callback' => 'user_access',
    'access arguments' => array('post comments'), // anyone logged in
  );
  return $items;
}

function resolve_multiple_users_form() {
  $userList = $_SESSION['multiple_users_to_resolve'];
  drupal_set_message(t('There appear to be several existing users on the central records database which may or may not be yours. They are users of the '.
        'following websites. Please tick the ones which you agree you have been a user of then press Save.'));
  $websites = array();
  foreach ($userList as $user) {
    if ($user->website_id!==variable_get('indicia_website_id', 0))
      $websites[$user->website_id] = $user->title;
  }
  $form['website_list'] = array(
    '#type'=>'fieldset',
    '#title'=>t('List of websites you might be a user of:')
  );
  $form['website_list']['websites'] = array(
    '#type' => 'checkboxes',
    '#options' => $websites
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save')
  );
  return $form;
}

function resolve_multiple_users_form_submit($form, &$form_state) {
  $userList = $_SESSION['multiple_users_to_resolve'];
  $listToMerge = array();
  $tickedWebsites = array();
  foreach($form_state['values']['websites'] as $website_id=>$ticked) {
    if ($ticked!==0) {
      $tickedWebsites[] = $website_id;
    }
  }
  foreach ($userList as $user) {
    if ($user->website_id===variable_get('indicia_website_id', 0) || in_array($user->website_id, $tickedWebsites))
      $listToMerge[] = $user->user_id;
  }
  $user = user_load($_SESSION['uid_to_resolve']);
  $response = easy_login_call_get_user_id($user, 'merge', $listToMerge);
  easy_login_handle_get_user_id_response($user, $response);
  drupal_goto('user/'.$user->uid.'/edit');
}

/**
 * Implementation of hook_user.
 * Traps login events and ensures the user is registered on the warehouse. Stores the user's ID in the local profile data.
 */
function easy_login_user($op, &$edit, &$account, $category = NULL) {
  static $_updating_account=false;
  if (!$_updating_account) {
    switch ($op) {
      case 'login':
        if (isset($account->profile_indicia_user_id))
          return;
        if (empty($account->profile_last_name)) {
          drupal_set_message('Please set at least your last name on your '.l('user account', 'user/'.$account->uid.'/edit/Name').
              '. This will allow your user registration to be linked properly to the central database of records.');
          return;
        }
        // deliberately flow through - as we always check the account id after account update. So do NOT break
      case 'submit':
      case 'insert':
        $_updating_account=true;
        $response = easy_login_call_get_user_id($account);
        easy_login_handle_get_user_id_response($account, $response, $op);
        $_updating_account=false;
    }
  }
}

/**
 * Function to call the get_user_id service on the warehouse.
 * @param object $account User object.
 * @param string $force Set to merge (to force a merge operation) or split (to force no merge).
 * @param array $users_to_merge If force is set to merge, but only some users must be merged,
 * pass an array of the user IDs.
 */
function easy_login_call_get_user_id($account, $force='null', $users_to_merge=null) {
  iform_load_helpers(array('data_entry_helper'));
  $url = data_entry_helper::$base_url.'index.php/services/user_identifier/get_user_id';
  $identifiers = array(array('type'=>'email','identifier'=>$account->mail));
  // add twitter, fb and openID accounts here
  // @todo OpenID and fb.
  if (module_exists('twitter')) {
    $twitterAccounts = twitter_get_user_accounts($account->uid);
    foreach ($twitterAccounts as $twitterAccount) {
      $identifiers[] = array('type'=>'twitter', 'identifier'=>$twitterAccount->screen_name);
    }
  }
  $identifiers = urlencode(json_encode($identifiers));
  $auth = data_entry_helper::get_read_write_auth(variable_get('indicia_website_id', ''), variable_get('indicia_password', ''));
  $url .= '?nonce='.$auth['write_tokens']['nonce'].'&auth_token='.$auth['write_tokens']['auth_token'].'&cms_user_id='.$account->uid;
  $postargs = 'surname='.urlencode($account->profile_last_name).'&identifiers='.$identifiers;
  if (!empty($account->profile_first_name))
    $postargs .= '&first_name='.urlencode($account->profile_first_name);
  if ($force && ($force==='merge' || $force==='split')) {
    $postargs .= '&force='.$force;
    // We are definitely doing something on the server, so can inform the user
    drupal_set_message(t('Your user information has been updated.'));
  }
  if ($users_to_merge)
    $postargs .= '&user_to_merge='.urlencode(json_encode($users_to_merge));
  $response = data_entry_helper::http_post($url, $postargs);
  return $response['output'];
}

function easy_login_handle_get_user_id_response($account, $response, $op=null) {
  if (preg_match('/^[0-9]+$/', $response)) {
    if (empty($account->profile_indicia_user_id))
      drupal_set_message(t('Your user account is now linked to the central records database.'));
    else if ($account->profile_indicia_user_id!=$response) {
      drupal_set_message(t('Your user account link to the central records database has been updated.'));
      if ($op==='login' || $op===null) {
        // Can use user_save during a login operation
        $r = db_fetch_array(db_query("SELECT fid FROM {profile_fields} WHERE name='profile_indicia_user_id'"));
        db_query("INSERT INTO {profile_values} (fid, uid, value) VALUES (%d, %d, '%s')", $r['fid'], $account->uid, $response['output']);
      } else
        // must set the edit array for the insert or update operation
        $edit['profile_indicia_user_id']=$response;
    }
  } else {
    // output not just a user ID, so should be either a json encoded error, or a list of possible users.
    $output = json_decode($response);
    if (isset($output->error))
      drupal_set_message($output->error, 'warning');
    elseif (is_array($output)) {
      $_SESSION['multiple_users_to_resolve'] = $output;
      $_SESSION['uid_to_resolve'] = $account->uid;
      drupal_goto('resolve_multiple_users');
    }
  }
}

/**
 * Alter the account form to load possible options for location and taxon group from the warehouse.
 */
function easy_login_form_alter(&$form, &$form_state, $form_id) {
  if (($form_id === 'user_profile_form' || $form_id === 'user_register') && array_key_exists('Preferences', $form)) {
    iform_load_helpers(array('data_entry_helper'));
    $readAuth = data_entry_helper::get_read_auth(variable_get('indicia_website_id', ''), variable_get('indicia_password', ''));
    // Load the list of locations
    $response = data_entry_helper::get_population_data(array(
      'table' => 'location',
      'extraParams' => $readAuth,
      'nocache' => true
    ));
    $locations=array(''=>'<Please select>');
    foreach ($response as $location) {
      $locations[$location['id']]=$location['name'];
    }
    $form['Preferences']['profile_location']['#options'] = $locations;
    $form['Preferences']['profile_location_expertise']['#options'] = $locations;
    $response = data_entry_helper::get_population_data(array(
      'table' => 'location',
      'extraParams' => $readAuth
    ));
    // Load the list of taxon groups
    $response = data_entry_helper::get_population_data(array(
      'table' => 'taxon_group',
      'extraParams' => $readAuth
    ));
    $groups=array();
    foreach ($response as $group) {
      $groups[$group['id']]=$group['title'];
    }
    $form['Preferences']['profile_taxon_groups']['#options'] = $groups;
    $form['Preferences']['profile_taxon_groups']['#prefix'] = '<div class="inline-divs">';
    $form['Preferences']['profile_taxon_groups']['#suffix'] = '</div>';
    if ($form_id === 'user_profile_form') {
      $form['Preferences']['profile_taxon_groups_expertise']['#options'] = $groups;
      $form['Preferences']['profile_taxon_groups_expertise']['#prefix'] = '<div class="inline-checkboxes">';
      $form['Preferences']['profile_taxon_groups_expertise']['#suffix'] = '</div>';
    }
    global $user;
    $thisUser = $user;
    // If we are editing someone else's form, then let's load their user account.
    if (isset($form['_account']['#value'])) {
      $values = $form['_account']['#value'];
      if (isset($values->uid))
        $thisUser = user_load($values->uid);
    }
    // can logged in user change expert geography and taxon groups?
    if (user_access('administer experts')) {
      $form['Preferences']['profile_location_expertise']['#attributes'] = array('readonly' => 'readonly');
      $form['Preferences']['profile_taxon_groups_expertise']['#attributes'] = array('readonly' => 'readonly');
    }
    // Is the user being edited an expert verifier? If not, no need for the profile fields
    if (!user_access('verifier', $thisUser)) {
      $form['Preferences']['profile_location_expertise']['#type'] = 'hidden';
      $form['Preferences']['profile_taxon_groups_expertise']['#type'] = 'hidden';
    }
  }

}