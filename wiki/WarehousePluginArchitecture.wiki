#summary How plugin modules extend the Warehouse functionality

=Indicia Warehouse Plugin Architecture=

The Indicia Warehouse has a set of core functions which are defined in the application folder. In addition, Kohana (the framework on which the Indicia Warehouse is built) supports modules which declare additional models, views and controllers. By default the module controllers provide additional URLs within the Warehouse, such as the URLs which support the web services or setup procedures. The functionality provided by Kohana modules therefore tends to be quite separate from the main application folder's functionality. However, within the Warehouse we have developed a method of defining modules which act as plugins, hooking their functionality into the existing Warehouse in a seamless way. At the moment the plugin architecture supports the modification of the main menu, e.g. to add a new page, as well as the insertion of a new tab onto an existing view page.

To create a plugin module, you need to create a folder for your module in the modules folder. Don't forget to enable your module in the application/config.php file as well or the module content will be ignored. Within this folder, you can create views, controllers and models folders for the MVC code your plugin requires. This should give you a new URL displaying some output where the URL path is defined by the controller class name and the methods it exposes. Now, you need to create a plugins folder within your module's folder, alongside the models, views and controllers folders. This is the extension to the module architecture developed specifically for Indicia. Within this folder, create a PHP file with the same name as your module folder. Inside this you need to write hook methods which follow a certain naming convention, allowing Indicia to ask your module about how it wants to plug in to the Warehouse. 

== extend_ui hook ==
This hook allows your module to declare extensions to the user interface of existing views. It simply returns an array of the extensions it wants to perform on the user interface. Each extension is a child array, containing a view (the path of the view it is extending), type (='tab'), controller (the path to the controller function which should be displayed on the tab), title (the title of the tab). For example:
{{{
function my_module_extend_ui() {
  return array(array(
    'view'=>'location/location_edit', 
    'type'=>'tab',
    'controller'=>'site_management_overview', 
    'title'=>'Site Management'
  ));
}
}}}

In this example, a new tab titled Site Management is attached to the view in application/views/location/location_edit.php. When clicked, the tab loads the content from the controllers/site_management_overview.php file within the plugin. This must declare a class Site_management_overview_Controller derived from Controller or one of its subclasses, with a public Index method since this is the default controller action.


== alter_menu hook ==
This hook allows your module to modify the main menu. Write a method called module_alter_menu replacing module for your module's folder name. It should take a single $menu parameter which is an array describing the main menu structure. It simply makes the modifications it requires setting the entries to the relevant controller path to be called by the new menu items, then returns the menu. The following example is from the log_browser plugin, and it is in a file modules/log_browser/plugins/log_browser.php:
{{{
<php
function log_browser_alter_menu($menu) {
  $menu['Admin']['Browse Server Logs']='browse_server_logs';
  return $menu;
}
?>
}}}

In this example, there is a controller file browse_server_logs.php, containing the class Browse_server_logs_Controller which declares a public index method (since the path in the above menu item does not specify the action, so the default index is used).