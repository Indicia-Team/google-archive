#summary Information on calling the Data Services

= Introduction =

Indicia's Data Services provide a programmatic interface to information held in the Indicia core database. The Data Services are a RESTful web service, with each entity represented by a URL.

All calls to the web services require a read nonce and auth_token to be attached as described under [DigestAuthentication Digest Authentication]. 

== Constructing the service URL ==

The Data Services are accessed via the URL of the site root + /index.php/services/data/ + the name of the required data entity, which is the singular version of the required table name, for example `http://www.mysite.com/index.php/services/data/termlist`

== Retrieving a single item of data ==

To retrieve a single item of data with a known id, append a forward slash then the item's id to the URL, for example `http://www.mysite.com/index.php/services/data/termlist/3` will retrieve the termlist with id 3.

== Retrieving a list of data ==

Retrieving a list of data can be achieved by ommitting the id from the URL. In this case, a number of parameters are available to control the output as follows. Each parameter can be provided as either a GET or a POST parameter. Typically you would use GET as this is a request for data rather than a post of data, but POST can be used in cases where this might result in an excessively long URL for example. 

||_fieldname_||If a parameter is provided which matches a field in the output data, then the value provided is used to filter on that field. When filtering against a text attribute, use an asterisk character to represent a wildcard if an inexact match is required. Use NULL to filter for null values.||
||orderby||Allows the field that the results are to be sorted by to be specified.||
||sortdir||Specifies the sort direction. Options are ASC or DESC.||
||limit||Limits the returned results to _n_ items.||
||offset||Starts the returned results offsetted by _n_ records.||
||wantRecords||Defaults to 1. If 1, then the returned data includes the records.||
||wantColumns||Defaults to 0. If 1, then the returned data includes the column definitions.||
||wantCount||Defaults to 0. If 1, then the returned data a count of the records in the results set.||
||auth_token||Used to provide the read authorisation token.||
||nonce||Used to provide the read authorisation nonce.||
||query||For advanced query building letting you pass a JSON object describing filters to apply to the query. Further details are given below || 

If both wantColumns and wantRecords are 1, then the returned object is divided into a records and a columns part at the top level.

An example illustrating a service call is `http://www.mysite.com/index.php/services/data/termlists_term?termlist=sample&term=quad&orderby=term&sortdir=desc&limit=10&offset=10&xsl=default.xsl&auth_token=x&nonce=y`. This returns an XML document formatted using default.xsl, which lists all termlist terms from termlists that contain sample in their title, where the term contains quad. The results start at the 10th item in the list, are limited to a maximum of 10 entries, and are ordered by term descending.

== Using the query parameter ==

Where a simple field filter is not sufficient, you can use the query parameter to build more advanced queries against the data. This is achieved by passing a JSON object in the query parameter. The top level of the object is an associative array of the filter type name, each containing a set of the parameters required for the filter type. So, for a simple example of a WHERE clause definition, you might pass the following using PHP which generates the SQL given:
{{{
'query' => urlencode(json_encode(array('where'=>array('survey_id', 5))))
WHERE survey_id=5
}}}
In the case where you need 2 where clauses, you can do 
{{{
'query' => urlencode(json_encode(array(
    'where'=>array(array('survey_id'=>5, 'entered_sref_system'=>'OSGB'))
)))
WHERE survey_id=5 AND entered_sref_system='OSGB'
}}}

The supported filter type names are as follows:

||where||Takes either 2 parameters, the fieldname and the value, or a single string parameter which is the join SQL, or an associative array of fieldnames and values. Multiple conditions are joined using an AND. If you need to support complex where syntax (e.g. wrapping parenthesis around 2 OR'ed statements) then this can be achieved by supplying a single string parameter containing the full SQL required for the WHERE clause.||
||orwhere||Identical to the where filter type, but conditions are joined using an OR.||
||in||Takes 2 parameters, a fieldname and an array of values to generate an IN (...) SQL clause.||
||notin||Identical to in but generates a NOT IN clause.||
||like||Takes 2 parameters, a fieldname and a value to generate a LIKE SQL statement.||
||orlike||Identical to the like filter type, but conditions are joined using an OR.||

More may be added in future.

== Output Attributes ==

Calls to the Data Services return a minimal amount of information for the entity by default, typically just the entity's id and caption field. The fields returned are those defined in the set of datasbase views called list_*** where *** is the table name. To return more details, specify a GET parameter "view=gv" or "view=detail", which returns either the columns in the main grid for the entity, or a detailed view of the entity respectively. Since additional query joins are required using these views will reduce performance.

== Output Mode ==

Calls to the URLs normally return a formatted XML document describing the results. This can be overridden by providing a GET parameter called mode in the URL to request json or csv data. Other formats can be supported by adding views that generate the formatted output to the modules/indicia_svc_data/views/services/data/_entity name_ folder.

=== JSONP ===

For cross-site retrieval using JSONP, an optional callback method can be specified by providing ?callback=_methodname_ in the GET string.

== Attaching XSL to XML output ==

By passing a GET parameter called xsl to the URL, an XSL transformation can be linked to by the returned XML document. Either a fully qualified path to the XSL document is required, or if just a file name is given then the XSL document must exist in the folder \media\services\stylesheets within the website root. An example file called default.xsl is provided. For example `http://www.mysite.com/index.php/services/data/termlist?xsl=default.xsl` retrieves the XML document listing all termlists into the browser and formats it on the client using the XSL file to appear as an HTML table.